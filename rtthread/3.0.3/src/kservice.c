#include <rtthread.h>
#include <rthw.h>






/* 复制n长度的字符串 */

char *rt_strncpy(char *dst, const char *src, rt_ubase_t n)
{
	if(n != 0)
	{
		char *d = dst;
		const char *s = src;
		
		do {
			if((*d++ = *s++) == 0)
			{
				/* NUL pad the remaining n-1 bytes */
				while(--n != 0)
					*d++ = 0;
				break;
			}
		}while(--n != 0);
			
	}
	return (dst);
}



#ifndef RT_USING_CPU_FFS



/*
 * __lowest_bit_bitmap90 数组的解析
 * 将一个八位整形数的范围 0-255 作为数组的索引，
 * 索引值第一个出现 1（从最低位开始）的位号作为该数组索引下的成员值。
 * 举例：十进制数 10 的二进制为 0000 1010 ，从最低位开始，
 * 第一个出现 1 的位号为 bit1 ，则有 __lowest_bit_bitmap[10] = 1
 * 注意：只需要找到第一个出现 1 的位号即可
 */

const rt_uint8_t __lowest_bit_bitmap[] =
{
    /* 00 */ 0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* 10 */ 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* 20 */ 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* 30 */ 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* 40 */ 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* 50 */ 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* 60 */ 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* 70 */ 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* 80 */ 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* 90 */ 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* A0 */ 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* B0 */ 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* C0 */ 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* D0 */ 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* E0 */ 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* F0 */ 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0
};


/* __rt_ffs 函数实现 */

/** 
 * 该函数用于从一个32位的数中寻找第一个被置 1 的位（从低位开始），
 * 然后返回该位的索引（即位号）
 *
 *返回第一个置 1 的索引号 。如果全为零，则返回零。
 */

int __rt_ffs(int value)
{
	/* 如果值为零，则直接返回零 */
	if(value == 0)  return 0;
	
	/* 检查 bits[07:00] */
	/* 这里加 1 是因为避免当第一个置 1 的位是位0 时，
	   返回的索引号与值都是 0 时返回索引号重复 */
	if(value & 0xff)
		return __lowest_bit_bitmap[value & 0xff] + 1;
	
	/* 检查 bits[15:08] */
	if(value & 0xff00)
		return __lowest_bit_bitmap[(value & 0xff00) >> 8] + 9;
	
	/* 检查 bits[23:16] */
	if(value & 0xff0000)
		return __lowest_bit_bitmap[(value & 0xff0000) >> 16] + 17;
	
	/* 检查 bits[31:24] */
		return __lowest_bit_bitmap[(value & 0xff000000) >> 24] + 25;
}


























#endif
















